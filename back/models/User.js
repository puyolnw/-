const { pool } = require('../config/database');
const bcrypt = require('bcryptjs');

class User {
  // ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏î‡πâ‡∏ß‡∏¢ username
  static async findByUsername(username) {
    try {
      const [rows] = await pool.execute(
        'SELECT * FROM users WHERE username = ?',
        [username]
      );
      return rows[0];
    } catch (error) {
      throw error;
    }
  }

  // ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏î‡πâ‡∏ß‡∏¢ email
  static async findByEmail(email) {
    try {
      const [rows] = await pool.execute(
        'SELECT * FROM users WHERE email = ?',
        [email]
      );
      return rows[0];
    } catch (error) {
      throw error;
    }
  }

  // ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏î‡πâ‡∏ß‡∏¢ ID
  static async findById(id) {
    try {
      console.log('üîµ Backend - User.findById called with ID:', id);
      
      // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ id ‡πÄ‡∏õ‡πá‡∏ô undefined ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
      if (id === undefined || id === null) {
        throw new Error('User ID cannot be undefined or null');
      }
      
      const [rows] = await pool.execute(
        'SELECT * FROM users WHERE id = ?',
        [id]
      );
      
      console.log('üîµ Backend - User.findById result:', rows[0]);
      return rows[0];
    } catch (error) {
      console.error('üîµ Backend - User.findById error:', error);
      throw error;
    }
  }

  // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡πÉ‡∏´‡∏°‡πà
  static async create(userData) {
    const {
      user_id,
      role,
      first_name,
      last_name,
      phone,
      email,
      address,
      username,
      password,
      school_id,
      student_code,
      faculty,
      major,
      profile_image
    } = userData;

    try {
      // Hash password
      const saltRounds = parseInt(process.env.BCRYPT_ROUNDS) || 10;
      const hashedPassword = await bcrypt.hash(password, saltRounds);

      // ‡∏™‡∏£‡πâ‡∏≤‡∏á query ‡πÅ‡∏ö‡∏ö dynamic ‡∏ï‡∏≤‡∏°‡∏ü‡∏¥‡∏•‡∏î‡πå‡∏ó‡∏µ‡πà‡∏°‡∏µ
      const fields = ['user_id', 'role', 'first_name', 'last_name', 'phone', 'email', 'address', 'username', 'password'];
      const values = [user_id, role, first_name, last_name, phone, email, address, username, hashedPassword];
      
        // ‡πÑ‡∏°‡πà‡πÄ‡∏û‡∏¥‡πà‡∏° school_id ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô foreign key constraint error
        // if (school_id) {
        //   fields.push('school_id');
        //   values.push(school_id);
        // }
      
      if (student_code) {
        fields.push('student_code');
        values.push(student_code);
      }
      
      if (faculty) {
        fields.push('faculty');
        values.push(faculty);
      }
      
      if (major) {
        fields.push('major');
        values.push(major);
      }
      
      if (profile_image) {
        fields.push('profile_image');
        values.push(profile_image);
      }
      
      const placeholders = fields.map(() => '?').join(', ');
      const query = `INSERT INTO users (${fields.join(', ')}) VALUES (${placeholders})`;

      const [result] = await pool.execute(query, values);

      return result.insertId;
    } catch (error) {
      throw error;
    }
  }

  // ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ
  static async update(id, userData) {
    const {
      first_name,
      last_name,
      phone,
      email,
      address,
      school_id,
      student_code,
      faculty,
      major,
      profile_image,
      advisor_name,
      advisor_phone,
      father_name,
      father_occupation,
      father_phone,
      mother_name,
      mother_occupation,
      mother_phone
    } = userData;

    try {
      // ‡∏™‡∏£‡πâ‡∏≤‡∏á dynamic query ‡∏ï‡∏≤‡∏°‡∏ü‡∏¥‡∏•‡∏î‡πå‡∏ó‡∏µ‡πà‡∏°‡∏µ
      const fields = [];
      const values = [];

      if (first_name !== undefined) {
        fields.push('first_name = ?');
        values.push(first_name);
      }
      if (last_name !== undefined) {
        fields.push('last_name = ?');
        values.push(last_name);
      }
      if (phone !== undefined) {
        fields.push('phone = ?');
        values.push(phone);
      }
      if (email !== undefined) {
        fields.push('email = ?');
        values.push(email);
      }
      if (address !== undefined) {
        fields.push('address = ?');
        values.push(address);
      }
      // ‡∏•‡∏ö‡∏Å‡∏≤‡∏£‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó school_id ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô foreign key constraint error
      // if (school_id !== undefined) {
      //   fields.push('school_id = ?');
      //   values.push(school_id);
      // }
      if (student_code !== undefined) {
        fields.push('student_code = ?');
        values.push(student_code);
      }
      if (faculty !== undefined) {
        fields.push('faculty = ?');
        values.push(faculty);
      }
      if (major !== undefined) {
        fields.push('major = ?');
        values.push(major);
      }
      if (profile_image !== undefined) {
        fields.push('profile_image = ?');
        values.push(profile_image);
      }
      
      // ‡∏ü‡∏¥‡∏•‡∏î‡πå‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ö‡∏∏‡∏Ñ‡∏Ñ‡∏•‡∏≠‡πâ‡∏≤‡∏á‡∏≠‡∏¥‡∏á
      if (advisor_name !== undefined) {
        fields.push('advisor_name = ?');
        values.push(advisor_name);
      }
      if (advisor_phone !== undefined) {
        fields.push('advisor_phone = ?');
        values.push(advisor_phone);
      }
      if (father_name !== undefined) {
        fields.push('father_name = ?');
        values.push(father_name);
      }
      if (father_occupation !== undefined) {
        fields.push('father_occupation = ?');
        values.push(father_occupation);
      }
      if (father_phone !== undefined) {
        fields.push('father_phone = ?');
        values.push(father_phone);
      }
      if (mother_name !== undefined) {
        fields.push('mother_name = ?');
        values.push(mother_name);
      }
      if (mother_occupation !== undefined) {
        fields.push('mother_occupation = ?');
        values.push(mother_occupation);
      }
      if (mother_phone !== undefined) {
        fields.push('mother_phone = ?');
        values.push(mother_phone);
      }

      if (fields.length === 0) {
        return true; // ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏≠‡∏∞‡πÑ‡∏£‡πÉ‡∏´‡πâ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï
      }

      values.push(id); // ‡πÄ‡∏û‡∏¥‡πà‡∏° id ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö WHERE clause

      const query = `UPDATE users SET ${fields.join(', ')} WHERE id = ?`;
      const [result] = await pool.execute(query, values);

      return result.affectedRows > 0;
    } catch (error) {
      throw error;
    }
  }

  // ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏£‡∏´‡∏±‡∏™‡∏ú‡πà‡∏≤‡∏ô
  static async updatePassword(id, newPassword) {
    try {
      const saltRounds = parseInt(process.env.BCRYPT_ROUNDS) || 10;
      const hashedPassword = await bcrypt.hash(newPassword, saltRounds);

      const [result] = await pool.execute(
        'UPDATE users SET password = ? WHERE id = ?',
        [hashedPassword, id]
      );

      return result.affectedRows > 0;
    } catch (error) {
      throw error;
    }
  }

  // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏£‡∏´‡∏±‡∏™‡∏ú‡πà‡∏≤‡∏ô
  static async verifyPassword(plainPassword, hashedPassword) {
    try {
      return await bcrypt.compare(plainPassword, hashedPassword);
    } catch (error) {
      throw error;
    }
  }

  // ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏ï‡∏≤‡∏° role
  static async findByRole(role) {
    try {
      const [rows] = await pool.execute(
        'SELECT id, user_id, role, first_name, last_name, phone, email, address, username, school_id, created_at FROM users WHERE role = ?',
        [role]
      );
      return rows;
    } catch (error) {
      throw error;
    }
  }

  // ‡∏•‡∏ö‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ
  static async delete(id) {
    try {
      const [result] = await pool.execute(
        'DELETE FROM users WHERE id = ?',
        [id]
      );
      return result.affectedRows > 0;
    } catch (error) {
      throw error;
    }
  }

  // ‡∏™‡∏£‡πâ‡∏≤‡∏á user_id ‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥‡∏ï‡∏≤‡∏° role
  static async generateUserId(role) {
    try {
      let prefix;
      switch (role) {
        case 'student':
          prefix = 'STD';
          break;
        case 'teacher':
          prefix = 'TCH';
          break;
        case 'supervisor':
          prefix = 'SUP';
          break;
        case 'admin':
          prefix = 'ADM';
          break;
        default:
          prefix = 'USR';
      }

      // ‡πÉ‡∏ä‡πâ transaction ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô race condition
      const connection = await pool.getConnection();
      await connection.beginTransaction();

      try {
        // ‡∏´‡∏≤‡πÄ‡∏•‡∏Ç‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î‡∏Ç‡∏≠‡∏á role ‡∏ô‡∏±‡πâ‡∏ô (‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏ó‡∏µ‡πà‡∏Ç‡∏∂‡πâ‡∏ô‡∏ï‡πâ‡∏ô‡∏î‡πâ‡∏ß‡∏¢ prefix ‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á)
        const [rows] = await connection.execute(
          'SELECT user_id FROM users WHERE role = ? AND user_id LIKE ? ORDER BY user_id DESC LIMIT 1 FOR UPDATE',
          [role, `${prefix}%`]
        );

        let nextNumber = 1;
        if (rows.length > 0) {
          const lastId = rows[0].user_id;
          // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ user_id ‡∏°‡∏µ‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á (prefix + ‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç)
          if (lastId.startsWith(prefix) && lastId.length > prefix.length) {
            const numberPart = parseInt(lastId.substring(prefix.length));
            if (!isNaN(numberPart)) {
              nextNumber = numberPart + 1;
            }
          }
        }

        const newUserId = `${prefix}${nextNumber.toString().padStart(3, '0')}`;
        
        // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ user_id ‡∏ô‡∏µ‡πâ‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
        const [existingUser] = await connection.execute(
          'SELECT id FROM users WHERE user_id = ?',
          [newUserId]
        );

        if (existingUser.length > 0) {
          // ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß ‡πÉ‡∏´‡πâ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏•‡∏Ç‡∏Ç‡∏∂‡πâ‡∏ô
          nextNumber++;
          const finalUserId = `${prefix}${nextNumber.toString().padStart(3, '0')}`;
          await connection.commit();
          connection.release();
          return finalUserId;
        }

        await connection.commit();
        connection.release();
        return newUserId;
      } catch (error) {
        await connection.rollback();
        connection.release();
        throw error;
      }
    } catch (error) {
      throw error;
    }
  }

  // ‡∏•‡∏ö‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ
  static async delete(id) {
    try {
      const [result] = await pool.execute(
        'DELETE FROM users WHERE id = ?',
        [id]
      );
      
      return result.affectedRows > 0;
    } catch (error) {
      throw error;
    }
  }
}

module.exports = User;
